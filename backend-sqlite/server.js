// optimized backend with SQLite Database and Authentication
const express = require('express');
const path = require('path');
const jwt = require('jsonwebtoken');
require('dotenv').config(); // Environment Variables laden

const Database = require('./database'); // SQLite Database Module

// Module Pattern f√ºr Server-Funktionalit√§t
const TaskServer = (function () {
    'use strict';
    
    // Private Konstanten und Konfiguration
    const PORT = process.env.PORT || 3000;
    const JWT_SECRET = process.env.JWT_SECRET;
    const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '24h';
    
    const STATUS = {
        OPEN: 'offen',
        COMPLETED: 'erledigt'
    };
    
    // Express App initialisieren
    const app = express();
    
    // JWT Secret Validierung
    if (!JWT_SECRET) {
        console.error('üö® FEHLER: JWT_SECRET nicht in .env definiert!');
        process.exit(1);
    }
    
    // Private Hilfsfunktionen
    
    // Validierungsfunktionen (strikte Typenpr√ºfung)
    const isValidTaskText = function (text) {
        return typeof text === 'string' && text.trim() !== '' && text.trim().length <= 500;
    };
    
    const isValidTaskId = function (id) {
        const numId = Number(id);
        return Number.isInteger(numId) && numId > 0;
    };
    
    const isValidUsername = function (username) {
        return typeof username === 'string' && 
               username.trim().length >= 3 && 
               username.trim().length <= 30 &&
               /^[a-zA-Z0-9_-]+$/.test(username.trim());
    };
    
    const isValidEmail = function (email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return typeof email === 'string' && emailRegex.test(email.trim());
    };
    
    const isValidPassword = function (password) {
        return typeof password === 'string' && 
               password.length >= 6 && 
               password.length <= 100;
    };
    
    // JWT Token Hilfsfunktionen
    const generateToken = function (user) {
        const payload = {
            userId: user.id,
            username: user.username,
            email: user.email
        };
        
        return jwt.sign(payload, JWT_SECRET, {
            expiresIn: JWT_EXPIRES_IN
        });
    };
    
    const verifyToken = function (token) {
        try {
            return jwt.verify(token, JWT_SECRET);
        } catch (error) {
            throw new Error('Ung√ºltiger Token');
        }
    };
    
    // Authentication Middleware
    const authenticateToken = async function (req, res, next) {
        console.log('üîê Pr√ºfe Authentication...');
        
        try {
            const authHeader = req.headers.authorization;
            
            if (!authHeader || !authHeader.startsWith('Bearer ')) {
                console.log('‚ùå Kein Authorization Header gefunden');
                return res.status(401).json({
                    error: 'Nicht authentifiziert',
                    message: 'Authorization Header mit Bearer Token erforderlich'
                });
            }
            
            const token = authHeader.substring(7); // "Bearer " entfernen
            console.log('üé´ Token gefunden, verifiziere...');
            
            // Token verifizieren
            const decoded = verifyToken(token);
            console.log('‚úÖ Token valid f√ºr User:', decoded.username);
            
            // User-Daten laden (f√ºr Sicherheit)
            const user = await Database.getUserById(decoded.userId);
            
            if (!user) {
                console.log('‚ùå User nicht mehr in Datenbank vorhanden');
                return res.status(401).json({
                    error: 'User nicht gefunden',
                    message: 'Token ist g√ºltig, aber User existiert nicht mehr'
                });
            }
            
            // User-Daten zu Request hinzuf√ºgen
            req.user = user;
            console.log('üë§ User authentifiziert:', user.username);
            
            next();
        } catch (error) {
            console.error('üö® Authentication Fehler:', error.message);
            
            if (error.name === 'TokenExpiredError') {
                return res.status(401).json({
                    error: 'Token abgelaufen',
                    message: 'Bitte erneut anmelden'
                });
            } else if (error.name === 'JsonWebTokenError') {
                return res.status(401).json({
                    error: 'Ung√ºltiger Token',
                    message: 'Token ist besch√§digt oder gef√§lscht'
                });
            } else {
                return res.status(401).json({
                    error: 'Authentication fehlgeschlagen',
                    message: error.message
                });
            }
        }
    };
    
    // Optional Authentication (f√ºr Legacy-Kompatibilit√§t)
    const optionalAuth = async function (req, res, next) {
        try {
            const authHeader = req.headers.authorization;
            
            if (authHeader && authHeader.startsWith('Bearer ')) {
                const token = authHeader.substring(7);
                const decoded = verifyToken(token);
                const user = await Database.getUserById(decoded.userId);
                
                if (user) {
                    req.user = user;
                    console.log('üë§ Optional Auth: User erkannt:', user.username);
                } else {
                    console.log('‚ö†Ô∏è Optional Auth: Token valid, aber User nicht gefunden');
                }
            } else {
                console.log('üìù Optional Auth: Kein Token - verwende Demo-User');
            }
            
            next();
        } catch (error) {
            console.log('‚ö†Ô∏è Optional Auth: Token ung√ºltig, verwende Demo-User');
            next(); // Fehler ignorieren, Demo-User verwenden
        }
    };
    
    // Middleware-Setup
    const setupMiddleware = function () {
        // JSON Parser
        app.use(express.json({
            limit: '1mb',
            strict: true
        }));
        
        // CORS f√ºr Frontend-Kommunikation (ROBUSTE L√ñSUNG)
        app.use(function (req, res, next) {
            console.log('üåê CORS Middleware - Request from:', req.headers.origin || 'no-origin');
            console.log('üåê Method:', req.method);
            console.log('üåê Path:', req.path);
            
            // CORS-Header IMMER setzen (f√ºr alle Requests)
            res.header('Access-Control-Allow-Origin', 'https://todo-app-fullstack-gamma.vercel.app');
            res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
            res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization');
            res.header('Access-Control-Allow-Credentials', 'true');
            res.header('Access-Control-Max-Age', '86400'); // 24 Stunden Cache f√ºr Preflight
            
            console.log('‚úÖ CORS Headers gesetzt f√ºr alle Requests');
            
            // OPTIONS-Requests (Preflight) sofort beantworten
            if (req.method === 'OPTIONS') {
                console.log('üîÑ OPTIONS (Preflight) Request - sende 204 No Content');
                res.status(204).end();
                return;
            }
            
            next();
        });
        
        // Request-Logging
        app.use(function (req, res, next) {
            const timestamp = new Date().toISOString();
            const hasAuth = req.headers.authorization ? 'üîê' : 'üìù';
            console.log(`${timestamp} - ${hasAuth} ${req.method} ${req.path}`);
            next();
        });
    };
    
    // ===== AUTHENTICATION ROUTE HANDLERS =====
    
    // POST /auth/register - Neuen User registrieren
    const handleRegister = async function (req, res) {
        console.log('üÜï REGISTER Request empfangen');
        console.log('üìã Request Body:', req.body);
        
        try {
            const { username, email, password } = req.body;
            
            // Validierung
            if (!isValidUsername(username)) {
                return res.status(400).json({
                    error: 'Ung√ºltiger Username',
                    message: 'Username: 3-30 Zeichen, nur Buchstaben, Zahlen, _ und -'
                });
            }
            
            if (!isValidEmail(email)) {
                return res.status(400).json({
                    error: 'Ung√ºltige E-Mail',
                    message: 'Bitte gib eine g√ºltige E-Mail-Adresse ein'
                });
            }
            
            if (!isValidPassword(password)) {
                return res.status(400).json({
                    error: 'Ung√ºltiges Passwort',
                    message: 'Passwort: 6-100 Zeichen erforderlich'
                });
            }
            
            console.log('‚úÖ Validation erfolgreich, erstelle User...');
            
            // User erstellen
            const newUser = await Database.createUser(username.trim(), email.trim(), password);
            
            // Token generieren
            const token = generateToken(newUser);
            
            console.log('üéâ User erfolgreich registriert:', newUser.username);
            
            res.status(201).json({
                message: 'User erfolgreich registriert',
                user: {
                    id: newUser.id,
                    username: newUser.username,
                    email: newUser.email,
                    createdAt: newUser.createdAt
                },
                token: token,
                expiresIn: JWT_EXPIRES_IN
            });
            
        } catch (error) {
            console.error('üö® Registration Fehler:', error);
            
            if (error.message.includes('bereits vergeben')) {
                res.status(409).json({
                    error: 'User bereits vorhanden',
                    message: error.message
                });
            } else {
                res.status(500).json({
                    error: 'Fehler bei der Registrierung',
                    message: error.message
                });
            }
        }
    };
    
    // POST /auth/login - User anmelden
    const handleLogin = async function (req, res) {
        console.log('üîë LOGIN Request empfangen');
        console.log('üìã Request Body (ohne Password):', { username: req.body.username });
        
        try {
            const { username, password } = req.body;
            
            if (!username || !password) {
                return res.status(400).json({
                    error: 'Fehlende Daten',
                    message: 'Username und Password erforderlich'
                });
            }
            
            console.log('üîê Authentifiziere User:', username);
            
            // User authentifizieren
            const user = await Database.authenticateUser(username.trim(), password);
            
            // Token generieren
            const token = generateToken(user);
            
            console.log('üéâ Login erfolgreich f√ºr User:', user.username);
            
            res.json({
                message: 'Erfolgreich angemeldet',
                user: {
                    id: user.id,
                    username: user.username,
                    email: user.email,
                    createdAt: user.createdAt
                },
                token: token,
                expiresIn: JWT_EXPIRES_IN
            });
            
        } catch (error) {
            console.error('üö® Login Fehler:', error.message);
            
            // Aus Sicherheitsgr√ºnden immer die gleiche Fehlermeldung
            res.status(401).json({
                error: 'Anmeldung fehlgeschlagen',
                message: 'Ung√ºltiger Username oder Passwort'
            });
        }
    };
    
    // GET /auth/me - Aktuelle User-Info abrufen
    const handleGetMe = async function (req, res) {
        console.log('üë§ GET ME Request f√ºr User:', req.user.username);
        
        try {
            // User-Daten sind bereits durch authenticateToken Middleware verf√ºgbar
            res.json({
                user: {
                    id: req.user.id,
                    username: req.user.username,
                    email: req.user.email,
                    createdAt: req.user.createdAt
                }
            });
        } catch (error) {
            console.error('üö® Get Me Fehler:', error);
            res.status(500).json({
                error: 'Fehler beim Laden der User-Daten',
                message: error.message
            });
        }
    };
    
    // POST /auth/logout - Abmelden (Client-side)
    const handleLogout = function (req, res) {
        console.log('üëã LOGOUT Request empfangen');
        
        // Bei JWT ist Logout haupts√§chlich Client-side (Token l√∂schen)
        // Server kann optional eine Blacklist f√ºhren, aber das ist f√ºr Basic Auth nicht n√∂tig
        
        res.json({
            message: 'Erfolgreich abgemeldet',
            instructions: 'Token auf Client-Seite l√∂schen'
        });
    };
    
    // ===== TASK ROUTE HANDLERS (Protected) =====
    
    // GET /tasks - Tasks f√ºr eingeloggten User abrufen
    const handleGetTasks = async function (req, res) {
        console.log("üìö GET /tasks - Lade Tasks aus SQLite");
        
        try {
            let tasks;
            
            if (req.user) {
                // Authentifizierter User - lade nur seine Tasks
                console.log("üë§ Lade Tasks f√ºr User:", req.user.username);
                tasks = await Database.getAllTasksForUser(req.user.id);
            } else {
                // Legacy-Modus f√ºr Demo-User (R√ºckw√§rtskompatibilit√§t)
                console.log("üìù Legacy-Modus: Lade Tasks f√ºr Demo-User");
                tasks = await Database.getAllTasks();
            }
            
            console.log("‚úÖ Tasks erfolgreich geladen:", tasks.length);
            res.json(tasks);
        } catch (error) {
            console.error('üö® Fehler beim Laden der Tasks:', error);
            res.status(500).json({
                error: 'Fehler beim Laden der Aufgaben',
                message: error.message
            });
        }
    };
    
    // POST /tasks - Neue Task f√ºr User erstellen
    const handleCreateTask = async function (req, res) {
        console.log("üÜï POST /tasks - Erstelle neue Task");
        
        try {
            const text = req.body && req.body.text;
            console.log("‚úèÔ∏è Aufgabentext:", text);
            
            if (!isValidTaskText(text)) {
                console.log("‚ùå Ung√ºltiger Text erkannt:", text);
                return res.status(400).json({
                    error: 'Ung√ºltiger Aufgabentext',
                    message: 'Text ist erforderlich, darf nicht leer sein und maximal 500 Zeichen haben'
                });
            }
            
            let newTask;
            
            if (req.user) {
                // Authentifizierter User
                console.log("üë§ Erstelle Task f√ºr User:", req.user.username);
                newTask = await Database.createTaskForUser(req.user.id, text.trim());
            } else {
                // Legacy-Modus f√ºr Demo-User
                console.log("üìù Legacy-Modus: Erstelle Task f√ºr Demo-User");
                newTask = await Database.createTask(text.trim());
            }
            
            console.log("‚ú® Neue Task erstellt:", newTask);
            
            res.status(201).json(newTask);
            console.log("‚úÖ Response gesendet an Frontend");
            
        } catch (error) {
            console.error("üö® FEHLER in handleCreateTask:", error);
            res.status(500).json({
                error: 'Fehler beim Erstellen der Aufgabe',
                message: error.message
            });
        }
    };
    
    // PUT /tasks/:id - Status einer Task √§ndern (nur eigene)
    const handleToggleTask = async function (req, res) {
        console.log("üîÑ PUT /tasks/:id - √Ñndere Task Status");
        
        try {
            const taskId = req.params.id;
            console.log("üÜî Task ID:", taskId);
            
            if (!isValidTaskId(taskId)) {
                return res.status(400).json({
                    error: 'Ung√ºltige Task-ID',
                    message: 'ID muss eine positive Ganzzahl sein'
                });
            }
            
            let updatedTask;
            
            if (req.user) {
                // Authentifizierter User - nur eigene Tasks
                console.log("üë§ Toggle Task f√ºr User:", req.user.username);
                updatedTask = await Database.toggleTaskStatusForUser(Number(taskId), req.user.id);
            } else {
                // Legacy-Modus f√ºr Demo-User
                console.log("üìù Legacy-Modus: Toggle Task f√ºr Demo-User");
                updatedTask = await Database.toggleTaskStatus(Number(taskId));
            }
            
            console.log("‚úÖ Task Status ge√§ndert:", updatedTask.status);
            res.json(updatedTask);
            
        } catch (error) {
            console.error('üö® Fehler beim Toggle Task Status:', error);
            
            if (error.message.includes('nicht gefunden') || error.message.includes('geh√∂rt nicht')) {
                res.status(404).json({
                    error: 'Aufgabe nicht gefunden',
                    message: 'Aufgabe nicht gefunden oder geh√∂rt nicht dir'
                });
            } else {
                res.status(500).json({
                    error: 'Fehler beim √Ñndern des Status',
                    message: error.message
                });
            }
        }
    };
    
    // DELETE /tasks/:id - Task l√∂schen (nur eigene)
    const handleDeleteTask = async function (req, res) {
        console.log("üóëÔ∏è DELETE /tasks/:id - L√∂sche Task");
        
        try {
            const taskId = req.params.id;
            
            if (!isValidTaskId(taskId)) {
                return res.status(400).json({
                    error: 'Ung√ºltige Task-ID',
                    message: 'ID muss eine positive Ganzzahl sein'
                });
            }
            
            let deletedTask;
            
            if (req.user) {
                // Authentifizierter User - nur eigene Tasks
                console.log("üë§ L√∂sche Task f√ºr User:", req.user.username);
                deletedTask = await Database.deleteTaskForUser(Number(taskId), req.user.id);
            } else {
                // Legacy-Modus f√ºr Demo-User
                console.log("üìù Legacy-Modus: L√∂sche Task f√ºr Demo-User");
                deletedTask = await Database.deleteTask(Number(taskId));
            }
            
            console.log("‚úÖ Task erfolgreich gel√∂scht");
            
            res.json({
                message: 'Aufgabe erfolgreich gel√∂scht',
                task: deletedTask
            });
            
        } catch (error) {
            console.error('üö® Fehler beim L√∂schen der Task:', error);
            
            if (error.message.includes('nicht gefunden') || error.message.includes('geh√∂rt nicht')) {
                res.status(404).json({
                    error: 'Aufgabe nicht gefunden',
                    message: 'Aufgabe nicht gefunden oder geh√∂rt nicht dir'
                });
            } else {
                res.status(500).json({
                    error: 'Fehler beim L√∂schen der Aufgabe',
                    message: error.message
                });
            }
        }
    };
    
    // DELETE /tasks?status=completed - Alle erledigten Tasks l√∂schen
    const handleDeleteCompleted = async function (req, res) {
        console.log("üßπ DELETE /tasks?status=completed - L√∂sche erledigte Tasks");
        
        try {
            const status = req.query.status;
            
            if (status !== 'completed' && status !== 'erledigt') {
                return res.status(400).json({
                    error: 'Ung√ºltiger Parameter',
                    message: 'Parameter status=completed oder status=erledigt erforderlich'
                });
            }
            
            let result;
            
            if (req.user) {
                // Authentifizierter User - nur eigene Tasks
                console.log("üë§ L√∂sche erledigte Tasks f√ºr User:", req.user.username);
                result = await Database.deleteCompletedTasksForUser(req.user.id);
            } else {
                // Legacy-Modus f√ºr Demo-User
                console.log("üìù Legacy-Modus: L√∂sche erledigte Tasks f√ºr Demo-User");
                result = await Database.deleteCompletedTasks();
            }
            
            console.log("‚úÖ Erledigte Tasks gel√∂scht:", result.deletedCount);
            res.json(result);
            
        } catch (error) {
            console.error('üö® Fehler beim L√∂schen erledigter Tasks:', error);
            res.status(500).json({
                error: 'Fehler beim L√∂schen erledigter Aufgaben',
                message: error.message
            });
        }
    };
    
    // PUT /tasks/:id/text - Task Text bearbeiten (nur eigene)
    const handleEditTaskText = async function (req, res) {
        console.log("‚úèÔ∏è PUT /tasks/:id/text - Bearbeite Task Text");
        
        try {
            const taskId = req.params.id;
            const newText = req.body && req.body.text;
            
            if (!isValidTaskId(taskId)) {
                return res.status(400).json({
                    error: 'Ung√ºltige Task-ID',
                    message: 'ID muss eine positive Ganzzahl sein'
                });
            }
            
            if (!isValidTaskText(newText)) {
                return res.status(400).json({
                    error: 'Ung√ºltiger Aufgabentext',
                    message: 'Text ist erforderlich, darf nicht leer sein und maximal 500 Zeichen haben'
                });
            }
            
            let updatedTask;
            
            if (req.user) {
                // Authentifizierter User - nur eigene Tasks
                console.log("üë§ Bearbeite Task f√ºr User:", req.user.username);
                updatedTask = await Database.updateTaskTextForUser(Number(taskId), req.user.id, newText.trim());
            } else {
                // Legacy-Modus f√ºr Demo-User
                console.log("üìù Legacy-Modus: Bearbeite Task f√ºr Demo-User");
                updatedTask = await Database.updateTaskText(Number(taskId), newText.trim());
            }
            
            console.log("‚úÖ Task Text erfolgreich aktualisiert");
            res.json(updatedTask);
            
        } catch (error) {
            console.error('üö® Fehler beim Bearbeiten des Task-Texts:', error);
            
            if (error.message.includes('nicht gefunden') || error.message.includes('geh√∂rt nicht')) {
                res.status(404).json({
                    error: 'Aufgabe nicht gefunden',
                    message: 'Aufgabe nicht gefunden oder geh√∂rt nicht dir'
                });
            } else {
                res.status(500).json({
                    error: 'Fehler beim Bearbeiten der Aufgabe',
                    message: error.message
                });
            }
        }
    };
    
    // Routen registrieren
    const setupRoutes = function () {
        // Authentication Routes (√∂ffentlich)
        app.post('/auth/register', handleRegister);
        app.post('/auth/login', handleLogin);
        app.post('/auth/logout', handleLogout);
        app.get('/auth/me', authenticateToken, handleGetMe);
        
        // Task Routes (mit optionaler Auth f√ºr Legacy-Kompatibilit√§t)
        app.get('/tasks', optionalAuth, handleGetTasks);
        app.post('/tasks', optionalAuth, handleCreateTask);
        app.put('/tasks/:id', optionalAuth, handleToggleTask);
        app.delete('/tasks/:id', optionalAuth, handleDeleteTask);
        app.delete('/tasks', optionalAuth, handleDeleteCompleted);
        app.put('/tasks/:id/text', optionalAuth, handleEditTaskText);
        
        // Health Check Route
        app.get('/health', function (req, res) {
            res.json({
                status: 'ok',
                message: 'Todo API with Authentication is running',
                timestamp: new Date().toISOString(),
                version: '2.0.0'
            });
        });
        
        // 404-Handler f√ºr unbekannte Routen
        app.use(function (req, res) {
            res.status(404).json({
                error: 'Route nicht gefunden',
                message: 'Die angeforderte URL ' + req.path + ' existiert nicht'
            });
        });
        
        // Globaler Error-Handler
        app.use(function (err, req, res, next) {
            console.error('üö® Unbehandelter Fehler:', err);
            res.status(500).json({
                error: 'Interner Serverfehler',
                message: 'Ein unerwarteter Fehler ist aufgetreten'
            });
        });
    };
    
    // Server starten (async f√ºr Datenbank-Initialisierung)
    const start = async function () {
        try {
            console.log('üöÄ Starte OPTIMIERTEN TODO-Server mit Authentication...');
            
            // Datenbank initialisieren
            await Database.initialize();
            
            setupMiddleware();
            setupRoutes();
            
            const server = app.listen(PORT, function () {
                console.log('üéâ TODO-Server mit Authentication gestartet:');
                console.log('- Port: ' + PORT);
                console.log('- Datenbank: SQLite (todos.db)');
                console.log('- JWT Secret: ' + (JWT_SECRET ? 'Konfiguriert ‚úÖ' : 'FEHLT ‚ùå'));
                console.log('- Zeit: ' + new Date().toISOString());
                console.log('- URL: http://localhost:' + PORT);
                console.log('');
                console.log('üì° Auth-Endpunkte:');
                console.log('- POST /auth/register - Registrierung');
                console.log('- POST /auth/login    - Anmeldung');
                console.log('- GET  /auth/me      - User-Info');
                console.log('- POST /auth/logout  - Abmeldung');
                console.log('');
                console.log('üìã Task-Endpunkte (Auth optional):');
                console.log('- GET    /tasks      - Tasks abrufen');
                console.log('- POST   /tasks      - Task erstellen');
                console.log('- PUT    /tasks/:id  - Status √§ndern');
                console.log('- DELETE /tasks/:id  - Task l√∂schen');
                console.log('');
                console.log('üéØ Bereit f√ºr Authentifizierung!');
            });
            
            // Graceful Shutdown (erweitert f√ºr Datenbank)
            const shutdown = async function (signal) {
                console.log('\nüõë ' + signal + ' empfangen. Server wird heruntergefahren...');
                
                server.close(async function () {
                    console.log('üì™ HTTP Server gestoppt');
                    
                    try {
                        await Database.close();
                        console.log('üóÑÔ∏è Datenbank geschlossen');
                        console.log('‚úÖ Graceful Shutdown abgeschlossen');
                        process.exit(0);
                    } catch (error) {
                        console.error('üö® Fehler beim Datenbankschlie√üen:', error);
                        process.exit(1);
                    }
                });
                
                // Force-Kill nach 10 Sekunden
                setTimeout(() => {
                    console.error('‚è∞ Forced Shutdown nach 10 Sekunden');
                    process.exit(1);
                }, 10000);
            };
            
            process.on('SIGINT', () => shutdown('SIGINT'));
            process.on('SIGTERM', () => shutdown('SIGTERM'));
            
            return server;
        } catch (error) {
            console.error('üö® Server-Start Fehler:', error);
            process.exit(1);
        }
    };
    
    // √ñffentliche API
    return {
        start: start,
        app: app // F√ºr Tests exportieren
    };
})();

// Server initialisieren und starten
TaskServer.start();